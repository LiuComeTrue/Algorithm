## 排序算法
### 1. 冒泡排序
冒泡排序就是在依次比较相邻两个数，将较大的数换到后面。比如a[0]和a[1]比较，将大数交换到a[1],接着再比较a[1]和a[2],一趟下来最大的数就出现再最后面了。接着再在剩下的数中取最大的数，多趟下来就排好序了。
### 2. 选择排序
选择排序就是选出数组中最小的数赋值给a[0],再选出第二小的数赋给a[1],依次类推。方法与冒泡排序一样，都是比较相邻两值，只不过不进行交换，而是记录索引值，找到最小的值的索引，再与a[0]进行交换值。
### 3. 插入排序
插入排序就是将数组中的数一个一个往有序序列中插入的过程。通常将数组第一个数当成一个有序序列，然后依次遍历后面的数，将一个数字插入前面有序序列的前面中间或者后面。
### 4. 快速排序
* 快速排序第一种做法就是选择一个基准数，将比基准数小的数移到左边，比基准数大的移到右边，然后对左边和右边也进行同样处理，递归后得到有序序列。做法就是
 * 设置左右指针，左指针指向序列的头部（即索引），右指针指向序列的尾部
 * 右指针先向前移动，直到找到比基准值小的值停下，然后左指针向后移动，直到找到比基准值大的值停下
 * 交换左右指针的值
 * 重复上述步骤知道左右指针相遇
 * 将基准值与左右指针的值交换（此时基准值左边的值都比它小，右边的值都比它大）
 * 对基准值左边序列递归调用上述操作
 * 对基准值右边序列递归调用上述操作
 * 注意：必须右指针先移动，因为通常选区第一个数为基准值，最后要将基准值与指针指向的值交换，只有右指针先动才能确保最后指针指向的数比基准值小。
* 快速排序另一种写法是挖坑填数法
 * 选择一个基准值，取出基准值temp
 * 同样设置左右指针，此时坑位就是左指针指向的temp值
 * 右指针先向前移动，直到找到比基准值小的值停下，将此时右指针的值填入坑位（即赋值给左指针处的值），右指针处成为新的坑位
 * 然后左指针向后移动，直到找到比基准值大的值停下，将此时左指针的值填入坑位（即赋值给右指针处的值），左指针处成为新的坑位
 * 直到左右指针相遇，将基准值temp赋给左右指针指向的坑位
 * 对基准值左边序列递归调用上述操作
 * 对基准值右边序列递归调用上述操作
### 5. 堆排序
堆排序就是建立一个大顶堆或小顶堆，堆就是一棵完全二叉树，根结点大于（小于）等于左右结点，可以用数组实现。大顶堆根为最大数，小顶堆根为最小数。将根节点取出，在剩下的数中重新构建堆，再依次取根结点直到最后一个数，取出的数就是排序好的。
* 用数组模仿堆的树结构，树从左到右从上到下将值存入数组，i为根结点，2*i+1则为左子结点，2*i+2则为右子结点
* 开始构造大顶堆，将整棵树当成只有根、左、右结点的数，根节点与左右子结点比较，子结点大就上移（根结点和子结点交换值），这样这棵树就是一个大顶堆了，然后将这棵树当成另一棵树的一个子结点，重复上述操作
* 从底向上构造大顶堆，如果上层不交换值，则保持原样，如果交换了值，要一直向下比较到叶子结点
* 从数组长度/2位置处开始向前遍历结点构造大顶堆，因为此处开始拥有子结点
* 当大顶堆构造完成，将根节点与数组最后一值交换（此时最大值在数组最后），再对长度减一的数组重新构造大顶堆，重复操作直到长度减到0，原数组就变为递增的有序序列了
### 6. 希尔排序
希尔排序是对直接插入排序的改进。在排序序列是正序的情况下，直接插入排序的时间复杂度是O(n)，希尔排序就是利用这个特性，先将原序列分成多个子序列进行插入排序，待原序列基本有序时，再对整个序列进行插入排序。
* 希尔排序分割子序列是以增量进行分割的，即当增量为2时，原序列中每隔2个数字的值就是属于同个子序列的
* 通常将原序列长度/2作为增量，当第一次对子序列拍好序后，再将增量/2进行排序，直到增量为1时，就是对整个原序列进行排序
### 7. 归并排序
归并排序是采用分治法，将原序列分为两个有序序列，再将两个有序序列合并成一个有序序列的过程。采用递归的方式，划分两个序列到最后是两个单个值的序列，然后进行合并，实际的排序都是再合并中进行的。

合并两个有序序列是通过同时遍历两个序列，比较两个序列第一位的大小，将较小的值赋给第三个存储数组temp[],然后将这个值从原序列中删除，再次比较两个序列第一位的大小，直到其中一个序列清空，把另一个序列的值加到temp[]后。时间复杂度是O(n)。

归并排序的时间复杂度是O(nlogn)。
